; ------------------------------------------------------------------------------------;
;	Лабораторная работа №1 по курсу Программирование на языке ассемблера				;
;	Вариант №2.6.																		;
;	Выполнил студент Бутрова Александра.												;
;																						;
;	Исходный модуль LabAssignment.asm													;
;	Содержит функцию на языке ассемблера, разработанную в соответствии с заданием		;
; ------------------------------------------------------------------------------------;
;	Задание:																			;
;		Реализовать фильтр Собеля обработки изображений									;

.DATA
Two		real4	2.0		; Константа 2
pixel	word	?		; Промежуточное звено для записи в FPU

.CODE
; ----------------------------------------------------------------------------------;
; Осуществляет фильтрацию одной цветовой составляющей изображения					  ;
; void Kernel_asm( PBYTE pDst, PBYTE pSrc, int Width )								  ;
; Параметры:																		  ;
;	pDst   - адрес пиксела - результата обработки									  ;
;   pSrc   - адрес пиксела исходного изображения									  ;
;	Width  - ширина изображения в пикселах (количество столбцов)					  ;
; Внимание!!! Для корректной работы приложения необходимо определить константы в файле;
;	Tuning.h в соответствии с заданием												  ;
; ----------------------------------------------------------------------------------;


; Будем рассматривать матрицу 3 х 3, где обрабатывать будем центральный пиксель z5

;	( z1  z2  z3 )	
;	( z4  z5  z6 )
;	( z7  z8  z9 ) 

; Вычислить z5 можно по формуле
; z5 = sqrt ( Gx*Gx + Gy*Gy )
; где Gx и Gy
; Gy = ( z8 - z2 ) * 2 + z7 + z9 - z1 - z3
; Gx = ( z6 - z4 ) * 2 + z3 + z9 - z1 - z7


Kernel PROC										; [RCX] - pDst
												; [RDX] - pSrc
												; R8    - Width

	fninit										; Инициализация FPU

; Будем вычислять Gy = ( z8 - z2 ) * 2 + z7 + z9 - z1 - z3

; В стек FPU не можем класть всего 1 байт, загружаемый из памяти.
; Поэтому, чтобы корректно пользовать FPU, будем загружать туда байты пикселей по следующей схеме:
;
;	достаем из памяти байт и кладём в регистр al 
;	расширенный регистр ax сохраняем в поле pixel
;   поле pixel загружаем в стек FPU

	
		

	
	
	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + R8*2 + 1 ]		; Помещаем байт пикселя 8 в регистр al
	mov		pixel, ax							; Помещаем содержимое регистра ax в поле pixel 
	fild	pixel								; Кладём в стек пиксель 8
	
	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + 1 ]				; Загружаем на стек пиксель 2
	mov		pixel, ax							 
	fild	pixel								
												; Стек:  z2, z8
	fsubp										; Разность запишем в st(0) и вытолкнем st(1)
	fmul    Two									; Умножаем st(0) на 2				
	
	
												; Стек:  (z2-z8)*2
	xor		ax, ax								; Занулим регистр ax											
	mov		al, byte ptr[ rdx + r8*2 ]			; Загружаем на стек пиксель 7
	mov		pixel, ax							
	fild	pixel								

	faddp										; Складываем st(0) и st(1) и выталкиваем st(1)						
												; Стек:  (z2-z8)*2 + z7
	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + r8*2 + 2 ]		; Загружаем на стек пиксель 9
	mov		pixel, ax
	fild	pixel 
	
	faddp										; Складываем и выталкиваем st(1)
												; Стек:  (z2-z8)*2 + z7 + z9
	xor		ax, ax								; Занулим регистр ax												
	mov		al, byte ptr[ rdx ]					; Загружаем на стек пиксель 1
	mov		pixel, ax
	fild	pixel 

	fsubp										; Отнимаем	и выталкиваем					
												; Стек:  (z2-z8)*2 + z7 + z9 - z1
	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + 2 ]				; Загружаем на стек пиксель 3
	mov		pixel, ax
	fild	pixel 
	
	fsubp										; Отнимаем, выталкиваем						 
												; Стек:  (z2-z8)*2 + z7 + z9 - z1 - z3 == Gy	
	
	fmul	st(0), st(0)						; Возводим в квадрат
												; Стек:  Gy*Gy

; Теперь вычислим Gx = (z6 - z4) * 2 + z3 + z9 - z1 - z7	
	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + r8 + 2 ]		; Загружаем на стек пиксель 6
	mov		pixel, ax
	fild	pixel 

	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + r8 ]			; Загружаем на стек пиксель 4
	mov		pixel, ax
	fild	pixel 
												; Стек:  z4, z6	
	fsubp										; Отнимаем и выталкиваем st(1)		
	fmul    Two									; Умножаем st(0) на 2				
												; Стек:  (z2 - z8)*2

	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + 2 ]				; Загружаем на стек пиксель 3
	mov		pixel, ax
	fild	pixel 
	
	faddp										; Прибавляем						
												; Стек:  (z8 - z2)*2 + z3

	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + r8*2 + 2 ]		; Загружаем на стек пиксель 9
	mov		pixel, ax
	fild	pixel 
	
	faddp										; Прибавляем, выталкиваем			
												; Стек:  (z2 - z8)*2 + z3 + z9 
	
	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx ]					; Загружаем на стек пиксель 1
	mov		pixel, ax
	fild	pixel 
	
	fsubp										; Отнимаем, выталкиваем				 
												; Стек:  (z2 - z8)*2 + z3 + z9 - z1
	
	xor		ax, ax								; Занулим регистр ax
	mov		al, byte ptr[ rdx + r8*2 ]			; Загружаем на стек пиксель 7
	mov		pixel, ax
	fild	pixel 
	
	fsubp										; Отнимаем, выталкиваем				 
												; Стек:  (z2 - z8)*2 + z3 + z9 - z7 == Gx	

	fmul	st(0), st(0)						; Возводим в квадрат 
												; Стек: Gx*Gx, Gy*Gy
	faddp										; Сложим их							 
	fsqrt										; И извлечём корень					 
												; Стек:  sqrt ( Gx*Gx + Gy*Gy )

	fistp	word ptr pixel						; Сохраним  st(0)  в Res

; Результат pixel после наших сложений, возведений в квадрат и извлечений корней может выйти за рамки одного байта.
; Поэтому необходимо ввести результат обратно в границы, если нужно.
; Меньше нуля уйти не могли, так как в конце использовали корень и возведение в квадрат.
; Проверим результат на превышение верхней границы, т.е. 255:
	xor		ax, ax								; Обнуляем регистр ax
	mov		ax, pixel							; ax := pixel (результат)
	mov		r9, 0FFh							; r9 := 255
	cmp		ax, r9w								; Сравнили результат и 255
	cmovg	ax, r9w								; если больше, то результат := 255
	mov		byte ptr [RCX], al					; Сохраняем результат по адресу результата обработки

	ffree	st(0)								; Очистим стек за собой	
	ffree	st(1)
	ffree	st(2)
	ffree	st(3)
	ffree	st(4)
	ffree	st(5)
	ffree	st(6)
	ffree	st(7)
	
		ret										; И вернёмся обратно
Kernel ENDP
END												; Конец :)
